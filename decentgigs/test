// decentgigs.ak - Smart Contract Escrow dengan Vodka Testing

// === IMPORTS ===
use aiken/collection/list
use aiken/crypto.{Blake2b_224, Hash, VerificationKey}
use cardano/address
use cardano/assets
use cardano/transaction.{Output, OutputReference, Transaction}

// Vodka Mocktail imports (struktur yang benar)
use mocktail.{
  complete, invalid_before, mocktail_tx, required_signer_hash, tx_in,
  tx_in_inline_datum, tx_out,
}
use mocktail/virgin_address.{mock_pub_key_address, mock_script_address}
use mocktail/virgin_key_hash.{mock_pub_key_hash}
use mocktail/virgin_output_reference.{mock_utxo_ref}

// === TIPE DATA ===
type VerificationKeyHash =
  Hash<Blake2b_224, VerificationKey>

pub type JobDatum {
  employer: VerificationKeyHash,
  freelancer: VerificationKeyHash,
  job_id: ByteArray,
}

pub type JobAction {
  ReleasePayment
  CancelJob
}

// === HELPER FUNCTIONS ===

fn must_be_signed_by(
  signatories: List<VerificationKeyHash>,
  signer: VerificationKeyHash,
) -> Bool {
  list.has(signatories, signer)
}

fn amount_sent_to(
  outputs: List<Output>,
  receiver: VerificationKeyHash,
  policy_id: ByteArray,
  asset_name: ByteArray,
) -> Int {
  let target_outputs =
    list.filter(
      outputs,
      fn(out) {
        out.address.payment_credential == address.VerificationKey(receiver)
      },
    )

  list.foldl(
    target_outputs,
    0,
    fn(out, total) { total + assets.quantity_of(out.value, policy_id, asset_name) },
  )
}

fn get_own_input_amount(
  tx: Transaction,
  out_ref: OutputReference,
  policy_id: ByteArray,
  asset_name: ByteArray,
) -> Int {
  expect Some(own_input) =
    list.find(tx.inputs, fn(input) { input.output_reference == out_ref })

  assets.quantity_of(own_input.output.value, policy_id, asset_name)
}

// === VALIDATOR UTAMA ===

validator decentgigs(usdm_policy_id: ByteArray, usdm_asset_name: ByteArray) {
  spend(
    datum: Option<JobDatum>,
    redeemer: JobAction,
    own_ref: OutputReference,
    tx: Transaction,
  ) {
    expect Some(d) = datum
    let signatories = tx.extra_signatories

    when redeemer is {
      ReleasePayment -> {
        let signed_by_employer = must_be_signed_by(signatories, d.employer)
        let signed_by_freelancer = must_be_signed_by(signatories, d.freelancer)
        let locked_amount =
          get_own_input_amount(tx, own_ref, usdm_policy_id, usdm_asset_name)
        let amount_to_freelancer =
          amount_sent_to(tx.outputs, d.freelancer, usdm_policy_id, usdm_asset_name)
        signed_by_employer && signed_by_freelancer && amount_to_freelancer >= locked_amount
      }

      CancelJob -> {
        let signed_by_employer = must_be_signed_by(signatories, d.employer)
        let signed_by_freelancer = must_be_signed_by(signatories, d.freelancer)
        let locked_amount =
          get_own_input_amount(tx, own_ref, usdm_policy_id, usdm_asset_name)
        let amount_to_employer =
          amount_sent_to(tx.outputs, d.employer, usdm_policy_id, usdm_asset_name)
        signed_by_employer && signed_by_freelancer && amount_to_employer >= locked_amount
      }
    }
  }
}

// === MOCK CONSTANTS ===

const employer_pkh: VerificationKeyHash = mock_pub_key_hash(1)

const freelancer_pkh: VerificationKeyHash = mock_pub_key_hash(2)

const rogue_pkh: VerificationKeyHash = mock_pub_key_hash(99)

const usdm_policy: ByteArray = #"01"

const usdm_asset: ByteArray = #"5553444d"

const job_datum =
  JobDatum { employer: employer_pkh, freelancer: freelancer_pkh, job_id: #"4a6f62313233" }

const own_input_ref: OutputReference = mock_utxo_ref(0, 0)

// === TEST HELPERS ===

fn make_usdm_value(amount: Int) {
  assets.from_asset(usdm_policy, usdm_asset, amount)
}

// Helper untuk membuat transaction dengan pattern yang konsisten
fn make_test_tx(
  locked_amount: Int,
  output_address: fn(Int, Option<a>) -> b,
  output_index: Int,
  include_employer_sig: Bool,
  include_freelancer_sig: Bool,
) {
  mocktail_tx()
    |> tx_in(True, own_input_ref, make_usdm_value(locked_amount))
    |> tx_in_inline_datum(True, job_datum)
    |> tx_out(True, output_address(output_index, None), make_usdm_value(locked_amount))
    |> required_signer_hash(include_employer_sig, employer_pkh)
    |> required_signer_hash(include_freelancer_sig, freelancer_pkh)
    |> complete()
}

// === TEST CASES ===

// Test 1: ReleasePayment Success - Kedua pihak setuju, dana ke freelancer
test release_payment_success() {
  let locked_amount = 1000

  let tx =
    mocktail_tx()
      |> tx_in(True, own_input_ref, make_usdm_value(locked_amount))
      |> tx_in_inline_datum(True, job_datum)
      |> tx_out(True, mock_pub_key_address(2, None), make_usdm_value(locked_amount))
      |> required_signer_hash(True, employer_pkh)
      |> required_signer_hash(True, freelancer_pkh)
      |> complete()

  decentgigs.spend(Some(job_datum), ReleasePayment, own_input_ref, tx)
}

// Test 2: ReleasePayment Fail - Hanya freelancer yang sign
test release_payment_fail_missing_employer_signature() {
  let locked_amount = 1000

  let tx =
    mocktail_tx()
      |> tx_in(True, own_input_ref, make_usdm_value(locked_amount))
      |> tx_in_inline_datum(True, job_datum)
      |> tx_out(True, mock_pub_key_address(2, None), make_usdm_value(locked_amount))
      |> required_signer_hash(False, employer_pkh)
      |> required_signer_hash(True, freelancer_pkh)
      |> complete()

  !decentgigs.spend(Some(job_datum), ReleasePayment, own_input_ref, tx)
}

// Test 3: ReleasePayment Fail - Dana tidak cukup ke freelancer
test release_payment_fail_insufficient_amount() {
  let locked_amount = 1000
  let sent_amount = 500

  let tx =
    mocktail_tx()
      |> tx_in(True, own_input_ref, make_usdm_value(locked_amount))
      |> tx_in_inline_datum(True, job_datum)
      |> tx_out(True, mock_pub_key_address(2, None), make_usdm_value(sent_amount))
      |> required_signer_hash(True, employer_pkh)
      |> required_signer_hash(True, freelancer_pkh)
      |> complete()

  !decentgigs.spend(Some(job_datum), ReleasePayment, own_input_ref, tx)
}

// Test 4: CancelJob Success - Dana dikembalikan ke employer
test cancel_job_success() {
  let locked_amount = 1000

  let tx =
    mocktail_tx()
      |> tx_in(True, own_input_ref, make_usdm_value(locked_amount))
      |> tx_in_inline_datum(True, job_datum)
      |> tx_out(True, mock_pub_key_address(1, None), make_usdm_value(locked_amount))
      |> required_signer_hash(True, employer_pkh)
      |> required_signer_hash(True, freelancer_pkh)
      |> complete()

  decentgigs.spend(Some(job_datum), CancelJob, own_input_ref, tx)
}

// Test 5: CancelJob Fail - Dana dikirim ke pihak ketiga (rogue)
test cancel_job_fail_rogue_recipient() {
  let locked_amount = 1000

  let tx =
    mocktail_tx()
      |> tx_in(True, own_input_ref, make_usdm_value(locked_amount))
      |> tx_in_inline_datum(True, job_datum)
      |> tx_out(True, mock_pub_key_address(99, None), make_usdm_value(locked_amount))
      |> required_signer_hash(True, employer_pkh)
      |> required_signer_hash(True, freelancer_pkh)
      |> complete()

  !decentgigs.spend(Some(job_datum), CancelJob, own_input_ref, tx)
}

// Test 6: CancelJob Fail - Missing freelancer signature
test cancel_job_fail_missing_freelancer_signature() {
  let locked_amount = 1000

  let tx =
    mocktail_tx()
      |> tx_in(True, own_input_ref, make_usdm_value(locked_amount))
      |> tx_in_inline_datum(True, job_datum)
      |> tx_out(True, mock_pub_key_address(1, None), make_usdm_value(locked_amount))
      |> required_signer_hash(True, employer_pkh)
      |> required_signer_hash(False, freelancer_pkh)
      |> complete()

  !decentgigs.spend(Some(job_datum), CancelJob, own_input_ref, tx)
}

// Test 7: ReleasePayment Fail - Missing freelancer signature
test release_payment_fail_missing_freelancer_signature() {
  let locked_amount = 1000

  let tx =
    mocktail_tx()
      |> tx_in(True, own_input_ref, make_usdm_value(locked_amount))
      |> tx_in_inline_datum(True, job_datum)
      |> tx_out(True, mock_pub_key_address(2, None), make_usdm_value(locked_amount))
      |> required_signer_hash(True, employer_pkh)
      |> required_signer_hash(False, freelancer_pkh)
      |> complete()

  !decentgigs.spend(Some(job_datum), ReleasePayment, own_input_ref, tx)
}

// === FUZZ TESTS ===

// Fuzz Test: Property - CancelJob harus mengembalikan jumlah penuh
test fuzz_cancel_must_return_full_amount(locked_amount via int) {
  let amount =
    if locked_amount < 0 {
      -locked_amount
    } else if locked_amount == 0 {
      1
    } else {
      locked_amount
    }

  let tx =
    mocktail_tx()
      |> tx_in(True, own_input_ref, make_usdm_value(amount))
      |> tx_in_inline_datum(True, job_datum)
      |> tx_out(True, mock_pub_key_address(1, None), make_usdm_value(amount))
      |> required_signer_hash(True, employer_pkh)
      |> required_signer_hash(True, freelancer_pkh)
      |> complete()

  decentgigs.spend(Some(job_datum), CancelJob, own_input_ref, tx)
}

// Fuzz Test: Property - ReleasePayment dengan amount random
test fuzz_release_payment_with_random_amount(locked_amount via int) {
  let amount =
    if locked_amount <= 0 {
      1
    } else {
      locked_amount
    }

  let tx =
    mocktail_tx()
      |> tx_in(True, own_input_ref, make_usdm_value(amount))
      |> tx_in_inline_datum(True, job_datum)
      |> tx_out(True, mock_pub_key_address(2, None), make_usdm_value(amount))
      |> required_signer_hash(True, employer_pkh)
      |> required_signer_hash(True, freelancer_pkh)
      |> complete()

  decentgigs.spend(Some(job_datum), ReleasePayment, own_input_ref, tx)
}